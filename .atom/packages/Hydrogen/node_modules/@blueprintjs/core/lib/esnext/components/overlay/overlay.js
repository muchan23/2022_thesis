/*
 * Copyright 2015 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Overlay_1;
import { __decorate } from "tslib";
import classNames from "classnames";
import * as React from "react";
import { findDOMNode } from "react-dom";
import { polyfill } from "react-lifecycles-compat";
import { CSSTransition, TransitionGroup } from "react-transition-group";
import { AbstractPureComponent2, Classes, Keys } from "../../common";
import { DISPLAYNAME_PREFIX } from "../../common/props";
import { isFunction } from "../../common/utils";
import { Portal } from "../portal/portal";
// HACKHACK: https://github.com/palantir/blueprint/issues/4342
// eslint-disable-next-line deprecation/deprecation
let Overlay = Overlay_1 = class Overlay extends AbstractPureComponent2 {
    constructor() {
        super(...arguments);
        this.state = {
            hasEverOpened: this.props.isOpen,
        };
        // an HTMLElement that contains the backdrop and any children, to query for focus target
        this.containerElement = null;
        // An empty, keyboard-focusable div at the beginning of the Overlay content
        this.startFocusTrapElement = null;
        // An empty, keyboard-focusable div at the end of the Overlay content
        this.endFocusTrapElement = null;
        this.refHandlers = {
            // HACKHACK: see https://github.com/palantir/blueprint/issues/3979
            /* eslint-disable-next-line react/no-find-dom-node */
            container: (ref) => (this.containerElement = findDOMNode(ref)),
            firstFocusable: (ref) => {
                this.startFocusTrapElement = ref;
                ref?.addEventListener("focusin", this.handleStartFocusTrapElementFocusIn);
            },
            lastFocusable: (ref) => {
                this.endFocusTrapElement = ref;
                ref?.addEventListener("focusin", this.handleEndFocusTrapElementFocusIn);
            },
        };
        this.maybeRenderChild = (child) => {
            if (isFunction(child)) {
                child = child();
            }
            if (child == null) {
                return null;
            }
            // add a special class to each child element that will automatically set the appropriate
            // CSS position mode under the hood.
            const decoratedChild = typeof child === "object" ? (React.cloneElement(child, {
                className: classNames(child.props.className, Classes.OVERLAY_CONTENT),
            })) : (React.createElement("span", { className: Classes.OVERLAY_CONTENT }, child));
            const { onOpening, onOpened, onClosing, transitionDuration, transitionName } = this.props;
            // a breaking change in react-transition-group types requires us to be explicit about the type overload here,
            // using a technique similar to Select.ofType() in @blueprintjs/select
            const CSSTransitionImplicit = CSSTransition;
            return (React.createElement(CSSTransitionImplicit, { classNames: transitionName, onEntering: onOpening, onEntered: onOpened, onExiting: onClosing, onExited: this.handleTransitionExited, timeout: transitionDuration, addEndListener: this.handleTransitionAddEnd }, decoratedChild));
        };
        /**
         * Ensures repeatedly pressing shift+tab keeps focus inside the Overlay. Moves focus to
         * the `endFocusTrapElement` or the first keyboard-focusable element in the Overlay (excluding
         * the `startFocusTrapElement`), depending on whether the element losing focus is inside the
         * Overlay.
         */
        this.handleStartFocusTrapElementFocusIn = (e) => {
            e.preventDefault();
            e.stopImmediatePropagation();
            if (e.relatedTarget != null &&
                this.containerElement.contains(e.relatedTarget) &&
                e.relatedTarget !== this.endFocusTrapElement) {
                this.endFocusTrapElement?.focus();
            }
            else {
                this.getKeyboardFocusableElements().shift()?.focus();
            }
        };
        /**
         * Ensures repeatedly pressing tab keeps focus inside the Overlay. Moves focus to the
         * `startFocusTrapElement` or the last keyboard-focusable element in the Overlay (excluding the
         * `startFocusTrapElement`), depending on whether the element losing focus is inside the
         * Overlay.
         */
        this.handleEndFocusTrapElementFocusIn = (e) => {
            e.preventDefault();
            e.stopImmediatePropagation();
            if (e.relatedTarget != null &&
                this.containerElement.contains(e.relatedTarget) &&
                e.relatedTarget !== this.startFocusTrapElement) {
                this.startFocusTrapElement?.focus();
            }
            else {
                const nextFocusableElement = this.getKeyboardFocusableElements().pop();
                if (nextFocusableElement != null) {
                    nextFocusableElement.focus();
                }
                else {
                    // Keeps focus within Overlay even if there are no keyboard-focusable children
                    this.startFocusTrapElement?.focus();
                }
            }
        };
        this.handleTransitionExited = (node) => {
            if (this.props.shouldReturnFocusOnClose && this.lastActiveElementBeforeOpened instanceof HTMLElement) {
                this.lastActiveElementBeforeOpened.focus();
            }
            this.props.onClosed?.(node);
        };
        this.handleBackdropMouseDown = (e) => {
            const { backdropProps, canOutsideClickClose, enforceFocus, onClose } = this.props;
            if (canOutsideClickClose) {
                onClose?.(e);
            }
            if (enforceFocus) {
                this.bringFocusInsideOverlay();
            }
            backdropProps?.onMouseDown?.(e);
        };
        this.handleDocumentClick = (e) => {
            const { canOutsideClickClose, isOpen, onClose } = this.props;
            // get the actual target even in the Shadow DOM
            const eventTarget = (e.composed ? e.composedPath()[0] : e.target);
            const stackIndex = Overlay_1.openStack.indexOf(this);
            const isClickInThisOverlayOrDescendant = Overlay_1.openStack
                .slice(stackIndex)
                .some(({ containerElement: elem }) => {
                // `elem` is the container of backdrop & content, so clicking on that container
                // should not count as being "inside" the overlay.
                return elem && elem.contains(eventTarget) && !elem.isSameNode(eventTarget);
            });
            if (isOpen && !isClickInThisOverlayOrDescendant && canOutsideClickClose) {
                // casting to any because this is a native event
                onClose?.(e);
            }
        };
        /**
         * When multiple Overlays are open, this event handler is only active for the most recently
         * opened one to avoid Overlays competing with each other for focus.
         */
        this.handleDocumentFocus = (e) => {
            // get the actual target even in the Shadow DOM
            const eventTarget = e.composed ? e.composedPath()[0] : e.target;
            if (this.props.enforceFocus &&
                this.containerElement != null &&
                eventTarget instanceof Node &&
                !this.containerElement.contains(eventTarget)) {
                // prevent default focus behavior (sometimes auto-scrolls the page)
                e.preventDefault();
                e.stopImmediatePropagation();
                this.bringFocusInsideOverlay();
            }
        };
        this.handleKeyDown = (e) => {
            const { canEscapeKeyClose, onClose } = this.props;
            // HACKHACK: https://github.com/palantir/blueprint/issues/4165
            /* eslint-disable-next-line deprecation/deprecation */
            if (e.which === Keys.ESCAPE && canEscapeKeyClose) {
                onClose?.(e);
                // prevent browser-specific escape key behavior (Safari exits fullscreen)
                e.preventDefault();
            }
        };
        this.handleTransitionAddEnd = () => {
            // no-op
        };
    }
    static getDerivedStateFromProps({ isOpen: hasEverOpened }) {
        if (hasEverOpened) {
            return { hasEverOpened };
        }
        return null;
    }
    render() {
        // oh snap! no reason to render anything at all if we're being truly lazy
        if (this.props.lazy && !this.state.hasEverOpened) {
            return null;
        }
        const { children, className, enforceFocus, usePortal, isOpen } = this.props;
        // TransitionGroup types require single array of children; does not support nested arrays.
        // So we must collapse backdrop and children into one array, and every item must be wrapped in a
        // Transition element (no ReactText allowed).
        const childrenWithTransitions = isOpen ? React.Children.map(children, this.maybeRenderChild) ?? [] : [];
        const maybeBackdrop = this.maybeRenderBackdrop();
        if (maybeBackdrop !== null) {
            childrenWithTransitions.unshift(maybeBackdrop);
        }
        if (isOpen && enforceFocus && childrenWithTransitions.length > 0) {
            childrenWithTransitions.unshift(this.renderDummyElement(this.refHandlers.firstFocusable, "__first"));
            childrenWithTransitions.push(this.renderDummyElement(this.refHandlers.lastFocusable, "__last"));
        }
        const containerClasses = classNames(Classes.OVERLAY, {
            [Classes.OVERLAY_OPEN]: isOpen,
            [Classes.OVERLAY_INLINE]: !usePortal,
        }, className);
        const transitionGroup = (React.createElement(TransitionGroup, { appear: true, "aria-live": "polite", className: containerClasses, component: "div", onKeyDown: this.handleKeyDown, ref: this.refHandlers.container }, childrenWithTransitions));
        if (usePortal) {
            return (React.createElement(Portal, { className: this.props.portalClassName, container: this.props.portalContainer }, transitionGroup));
        }
        else {
            return transitionGroup;
        }
    }
    componentDidMount() {
        if (this.props.isOpen) {
            this.overlayWillOpen();
        }
    }
    componentDidUpdate(prevProps) {
        if (prevProps.isOpen && !this.props.isOpen) {
            this.overlayWillClose();
        }
        else if (!prevProps.isOpen && this.props.isOpen) {
            this.overlayWillOpen();
        }
    }
    componentWillUnmount() {
        this.overlayWillClose();
    }
    /**
     * @public for testing
     * @internal
     */
    bringFocusInsideOverlay() {
        // always delay focus manipulation to just before repaint to prevent scroll jumping
        return this.requestAnimationFrame(() => {
            // container ref may be undefined between component mounting and Portal rendering
            // activeElement may be undefined in some rare cases in IE
            if (this.containerElement == null || document.activeElement == null || !this.props.isOpen) {
                return;
            }
            const isFocusOutsideModal = !this.containerElement.contains(document.activeElement);
            if (isFocusOutsideModal) {
                // element marked autofocus has higher priority than the other clowns
                const autofocusElement = this.containerElement.querySelector("[autofocus]");
                const firstKeyboardFocusableElement = this.getKeyboardFocusableElements().shift();
                if (autofocusElement != null) {
                    autofocusElement.focus();
                }
                else if (firstKeyboardFocusableElement != null) {
                    firstKeyboardFocusableElement.focus();
                }
                else {
                    this.startFocusTrapElement?.focus();
                }
            }
        });
    }
    maybeRenderBackdrop() {
        const { backdropClassName, backdropProps, hasBackdrop, isOpen, transitionDuration, transitionName, } = this.props;
        if (hasBackdrop && isOpen) {
            return (React.createElement(CSSTransition, { classNames: transitionName, key: "__backdrop", timeout: transitionDuration, addEndListener: this.handleTransitionAddEnd },
                React.createElement("div", Object.assign({}, backdropProps, { className: classNames(Classes.OVERLAY_BACKDROP, backdropClassName, backdropProps?.className), onMouseDown: this.handleBackdropMouseDown }))));
        }
        else {
            return null;
        }
    }
    renderDummyElement(ref, key) {
        const { transitionDuration, transitionName } = this.props;
        return (React.createElement(CSSTransition, { classNames: transitionName, key: key, addEndListener: this.handleTransitionAddEnd, timeout: transitionDuration, unmountOnExit: true },
            React.createElement("div", { ref: ref, tabIndex: 0 })));
    }
    getKeyboardFocusableElements() {
        const focusableElements = this.containerElement !== null
            ? Array.from(
            // Order may not be correct if children elements use tabindex values > 0.
            // Selectors derived from this SO question:
            // https://stackoverflow.com/questions/1599660/which-html-elements-can-receive-focus
            this.containerElement.querySelectorAll([
                'a[href]:not([tabindex="-1"])',
                'button:not([disabled]):not([tabindex="-1"])',
                'details:not([tabindex="-1"])',
                'input:not([disabled]):not([tabindex="-1"])',
                'select:not([disabled]):not([tabindex="-1"])',
                'textarea:not([disabled]):not([tabindex="-1"])',
                '[tabindex]:not([tabindex="-1"])',
            ].join(",")))
            : [];
        if (this.props.enforceFocus) {
            // The first and last elements are dummy elements that help trap focus when enforceFocus
            // is enabled
            focusableElements.shift();
            focusableElements.pop();
        }
        return focusableElements;
    }
    overlayWillClose() {
        document.removeEventListener("focus", this.handleDocumentFocus, /* useCapture */ true);
        document.removeEventListener("mousedown", this.handleDocumentClick);
        this.startFocusTrapElement?.removeEventListener("focusin", this.handleStartFocusTrapElementFocusIn);
        this.endFocusTrapElement?.removeEventListener("focusin", this.handleEndFocusTrapElementFocusIn);
        const { openStack } = Overlay_1;
        const stackIndex = openStack.indexOf(this);
        if (stackIndex !== -1) {
            openStack.splice(stackIndex, 1);
            if (openStack.length > 0) {
                const lastOpenedOverlay = Overlay_1.getLastOpened();
                if (lastOpenedOverlay.props.enforceFocus) {
                    lastOpenedOverlay.bringFocusInsideOverlay();
                    document.addEventListener("focus", lastOpenedOverlay.handleDocumentFocus, /* useCapture */ true);
                }
            }
            if (openStack.filter(o => o.props.usePortal && o.props.hasBackdrop).length === 0) {
                document.body.classList.remove(Classes.OVERLAY_OPEN);
            }
        }
    }
    overlayWillOpen() {
        const { getLastOpened, openStack } = Overlay_1;
        if (openStack.length > 0) {
            document.removeEventListener("focus", getLastOpened().handleDocumentFocus, /* useCapture */ true);
        }
        openStack.push(this);
        if (this.props.autoFocus) {
            this.bringFocusInsideOverlay();
        }
        if (this.props.enforceFocus) {
            // Focus events do not bubble, but setting useCapture allows us to listen in and execute
            // our handler before all others
            document.addEventListener("focus", this.handleDocumentFocus, /* useCapture */ true);
        }
        if (this.props.canOutsideClickClose && !this.props.hasBackdrop) {
            document.addEventListener("mousedown", this.handleDocumentClick);
        }
        if (this.props.hasBackdrop && this.props.usePortal) {
            // add a class to the body to prevent scrolling of content below the overlay
            document.body.classList.add(Classes.OVERLAY_OPEN);
        }
        this.lastActiveElementBeforeOpened = document.activeElement;
    }
};
Overlay.displayName = `${DISPLAYNAME_PREFIX}.Overlay`;
Overlay.defaultProps = {
    autoFocus: true,
    backdropProps: {},
    canEscapeKeyClose: true,
    canOutsideClickClose: true,
    enforceFocus: true,
    hasBackdrop: true,
    isOpen: false,
    lazy: true,
    shouldReturnFocusOnClose: true,
    transitionDuration: 300,
    transitionName: Classes.OVERLAY,
    usePortal: true,
};
Overlay.openStack = [];
Overlay.getLastOpened = () => Overlay_1.openStack[Overlay_1.openStack.length - 1];
Overlay = Overlay_1 = __decorate([
    polyfill
], Overlay);
export { Overlay };
//# sourceMappingURL=overlay.js.map